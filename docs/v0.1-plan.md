# v0.1 Local‑Only Architecture & Plan

This document defines a minimal, local‑only v0.1 on the path to PRD v1. It delivers the core feel of Runs and Sessions with a single machine setup, no containers, no auth, and no cloud dependencies.

## Summary
- Single process service that exposes REST + minimal HTML UI.
- Supports one‑shot Runs and multi‑turn Sessions for a single whitelisted agent (`codex`) against a local Git repo.
- Stores metadata in SQLite, logs on disk, and transcripts in DB.
- Mobile‑usable UI via simple server‑rendered pages and polling.

## Goals
- Launch a Run and view status + log tail locally.
- Start a Session on a repo branch with an auto‑named Git worktree; send/receive multi‑turn messages.
- Enforce a single in‑flight user turn per Session.
- Operate offline on one machine (localhost or LAN).

## Non‑Goals
- No containers, reverse proxy, or port publishing.
- No multi‑user auth, RBAC, or team concepts.
- No WebSockets or token‑by‑token streaming (poll JSON instead).
- No cloud persistence (Postgres/S3) or push notifications.

## Constraints & Assumptions
- Trust the local machine; single user.
- macOS/Linux only for v0.1.
- `codex` CLI is installed and available on PATH.
- Git repo is present locally; we can create a worktree in it.

## High‑Level Architecture
- One binary/process (`awrapper`) with three modules:
  1) API + UI: HTTP server serving REST and small server‑rendered pages.
  2) Runner: in‑process queue that executes one‑shot Runs.
  3) Session Supervisor: manages long‑lived CLI processes for Sessions.

### Storage
- SQLite DB file at `~/.awrapper/awrapper.db`.
- Logs at `~/.awrapper/logs/<run_or_session_id>.log`.
- Artifacts (optional) at `~/.awrapper/artifacts/<id>/`.
- Config/registry loaded from in‑process constants (no external files needed).

### Directory Layout (created on first run)
```
~/.awrapper/
  awrapper.db
  logs/
    run-<id>.log
    session-<id>.log
  artifacts/
    run-<id>/...
```

### Agents Registry (v0.1)
- Static, in‑code registry:
  - id: `codex`
  - command_template: `codex --headless --workdir .` (example; finalized per local install)
  - allowed_params: minimal flags supported (e.g., `--model`, `--max-tokens`)
  - env_defaults: optional defaults

## Data Model (SQLite)
- Agent: `id TEXT PRIMARY KEY`, `name TEXT`, `command_template TEXT`, `allowed_params_json TEXT`, `env_defaults_json TEXT`.
- Run: `id TEXT PRIMARY KEY`, `agent_id TEXT`, `params_json TEXT`, `status TEXT`, `started_at INTEGER`, `finished_at INTEGER`, `exit_code INTEGER`, `log_path TEXT`, `error_message TEXT`.
- Session: `id TEXT PRIMARY KEY`, `agent_id TEXT`, `repo_path TEXT`, `branch TEXT`, `worktree_path TEXT`, `status TEXT`, `pid INTEGER`, `started_at INTEGER`, `last_activity_at INTEGER`, `error_message TEXT`.
- Message: `id TEXT PRIMARY KEY`, `session_id TEXT`, `turn_id TEXT`, `role TEXT`, `content TEXT`, `created_at INTEGER`.

Notes:
- `status` enums: Run → `queued|running|finished|failed|canceled|timed_out`; Session → `open|closed`.
- Use INTEGER timestamps (ms since epoch) for simplicity.
- `turn_id` groups one user message with its assistant reply.

## Git Worktree Strategy
- Validate `repo_path` is a Git repo (check `.git` or `git rev-parse`).
- On Session create:
  - Worktree path: `<repo_path>/.awrapper-worktrees/<session_id>`
  - Command: `git -C <repo_path> worktree add -b aw/<session_id> <worktree_path> <branch>` (or reuse an existing branch; configurable)
  - Set Session cwd to the worktree.
- Clean up on Session close (v0.1 can leave worktree in place for simplicity; add cleanup in later versions).

## Process Execution Model

### Runs (one‑shot)
- Enqueue Run in an in‑proc queue.
- Dequeue and spawn child process with:
  - `cwd = params.repo_path` (or a chosen directory depending on the agent)
  - stdout/stderr appended to `log_path`
  - On exit: save `exit_code`, set status, and close resources.
- Cancel: send SIGTERM; escalate to SIGKILL after grace period.

### Sessions (multi‑turn)
- Create Session: spawn long‑lived `codex` process in the worktree directory.
- User turn handling:
  - Enforce only one in‑flight turn via in‑memory mutex (per Session id).
  - Write user message to the process stdin with a delimiter if required by the CLI.
  - Collect process output until end‑of‑turn using one of:
    1) Known CLI turn delimiter/marker (preferred), or
    2) Quiet‑period flush (e.g., 500–800ms of no new bytes), or
    3) Prompt detection heuristic if available.
  - Persist one assistant Message for the turn with the captured text.
  - Update `last_activity_at`.
- Session termination: if underlying process exits, mark Session `closed` and record `exit_code` in `error_message` if non‑zero.

## REST API (v0.1)

### Runs
- POST `/runs` — body: `{ agent_id, params }` → `{ id }`
- GET `/runs` — list recent runs with status
- GET `/runs/:id` — detail: status, times, exit_code
- GET `/runs/:id/log?tail=200` — last N lines (default 200)
- POST `/runs/:id/cancel` — best effort terminate
- GET `/runs/:id/artifacts` — list files under artifacts dir (if present)

### Sessions
- POST `/sessions` — `{ agent_id: "codex", repo_path, branch?, initial_message? }` → `{ id, worktree_path }`
- GET `/sessions` — list recent sessions with status
- GET `/sessions/:id` — detail: repo/branch/worktree, pid, status, last_activity_at, last N messages
- GET `/sessions/:id/messages?after=<message_id>` — messages after an id
- POST `/sessions/:id/messages` — `{ content }` → `{ message_id }` (queues a single user turn)

## Minimal UI (Server‑Rendered + Fetch)
- Dashboard `/` — links to Runs and Sessions
- Runs List `/runs` — table with status; “New Run” form
- Run Detail `/runs/:id` — status, times, log tail (poll every 5–10s), cancel button
- Sessions List `/sessions` — table with status; “New Session” form
- Session Detail `/sessions/:id` — transcript view, input box, disabled state while a turn is in flight (poll every 5–10s)

## Logging & Redaction
- Append stdout/stderr to log files per Run/Session.
- Basic redaction for obvious secrets (e.g., redact tokens using regex patterns) before persisting to logs/transcripts.

## Configuration
- Defaults compiled in; optional `~/.awrapper/config.json` for overrides later.
- For v0.1, allow specifying paths and polling intervals via env vars if needed.

## Tech Stack
- Option A (recommended): Node.js + TypeScript
  - HTTP: Fastify (or Express)
  - DB: `better-sqlite3`
  - PTY: `node-pty` (only if the CLI needs a TTY)
  - Logging: `pino`
- Option B: Python
  - HTTP: FastAPI
  - DB: `sqlite3` / `sqlmodel`
  - PTY: `ptyprocess`

## Implementation Plan

Phase 0 — Skeleton (0.5 day)
- Create project, init DB file/dirs under `~/.awrapper` on boot
- Health route and minimal HTML layout

Phase 1 — Data & Registry (1 day)
- SQLite schema and simple migration on boot
- In‑code agents registry with `codex`
- Input validation utilities

Phase 2 — Runs (1–1.5 days)
- Endpoints: create/list/detail/log tail/cancel
- In‑proc queue and child process spawn
- Log capture; error handling; cancel escalation
- Runs UI: list + detail with polling

Phase 3 — Sessions (2–3 days)
- Git worktree creation and validation
- Session supervisor with long‑lived process management
- Message in‑flight lock; quiet‑period end‑of‑turn
- Transcript persistence; Session UI with polling

Phase 4 — Polish (0.5–1 day)
- Empty/error states; mobile CSS improvements
- Basic secret redaction; simple metrics (counts, durations)

Phase 5 — Packaging (0.5 day)
- `awrapper dev` and `awrapper start` commands
- README quickstart

## Acceptance Criteria
- Run created from UI returns id quickly; status/log tail visible; cancel works.
- Session created on a chosen repo/branch with auto‑named worktree; can send two user turns and receive assistant replies; single in‑flight turn enforced.
- DB persists across restarts; logs on disk; UI usable on phone via LAN.

## Risks & Mitigations
- End‑of‑turn detection fragile → prefer CLI markers; add quiet‑period fallback with conservative thresholds.
- PTY quirks on macOS/Linux → avoid PTY unless required; if needed, scope to Sessions only.
- File watching or heavy tools in worktree → recommend polling flags in toolchains; v0.1 focuses on CLI interactions, not dev servers.

## Upgrade Path to PRD v1
- Isolation: replace local processes with rootless containers per Session.
- Networking: port publishing and discovery; optional reverse proxy for previews.
- Transport: WebSockets for faster updates; keep polling fallback.
- Security: single‑user token; later multi‑user Postgres + S3.
- UI: PWA polish; artifact viewers and richer previews.

## Open Questions
- Exact `codex` headless invocation and EOT markers for reliable turn segmentation.
- Whether to auto‑cleanup worktrees on Session close in v0.1 or defer.
- Need for minimal per‑Session configuration (env vars, PATH tweaks) in local mode.

