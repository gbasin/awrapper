# v0.1 Local Orchestrator Architecture & Plan

This document defines a minimal, local v0.1 on the path to PRD v1. It delivers the core feel using a single machine setup, no containers, no auth, and no cloud backend. Agents themselves may perform outbound API calls (e.g., OpenAI) as needed.

## Summary
- Single process service that exposes REST + minimal HTML UI.
- Unified concept: everything is a Session. "One‑shot" flows are Sessions with `lifecycle = "oneshot"`; multi‑turn are `lifecycle = "persistent"`.
- Supports the `codex` agent against a local Git repo/worktree.
- Stores metadata in SQLite, logs on disk, transcripts in DB; links to agent‑native logs when available.
- Mobile‑usable UI via simple server‑rendered pages and polling.
 - Default lifecycle: `persistent`.

## Goals
- Create a Session and view status + log tail locally.
- Start a Session on a repo branch with an auto‑named Git worktree; send/receive turns.
- Enforce a single in‑flight user turn per Session.
- Operate with a local orchestrator (no cloud backend); agents may require outbound network.

## Non‑Goals
- No containers, reverse proxy, or port publishing.
- No multi‑user auth, RBAC, or team concepts.
- No WebSockets or token‑by‑token streaming (poll JSON instead).
- No cloud persistence (Postgres/S3) or push notifications.

## Constraints & Assumptions
- Trust the local machine; single user.
- macOS/Linux only for v0.1.
- `codex` CLI is installed and available on PATH.
- Git repo is present locally; we can create a worktree in it.
- Outbound network access is allowed for agents (e.g., to OpenAI); orchestrator itself is local‑only.

## High‑Level Architecture
- One binary/process (`awrapper`) with two core modules:
  1) API + UI: HTTP server serving REST and small server‑rendered pages.
  2) Session Supervisor: manages Session lifecycle (both one‑shot and multi‑turn) and underlying processes.

### Storage
- SQLite DB file at `~/.awrapper/awrapper.db`.
- Logs at `~/.awrapper/logs/<run_or_session_id>.log`.
- Artifacts (optional) at `~/.awrapper/artifacts/<id>/`.
- Config/registry loaded from in‑process constants (no external files needed).

### Directory Layout (created on first run)
```
~/.awrapper/
  awrapper.db
  logs/
    run-<id>.log
    session-<id>.log
  artifacts/
    run-<id>/...
```

### Agents Registry (v0.1)
- Static, in‑code registry:
  - id: `codex`
  - command_template: `codex --headless --workdir .` (example; finalize per install)
  - allowed_params: minimal flags supported (e.g., `--model`, `--max-tokens`)
  - env_defaults: optional defaults
  - logging_hints: known agent log locations/patterns (e.g., `~/.codex/*.log`)

## Data Model (SQLite)
- Agent: `id TEXT PRIMARY KEY`, `name TEXT`, `command_template TEXT`, `allowed_params_json TEXT`, `env_defaults_json TEXT`, `logging_hints_json TEXT`.
- Session: `id TEXT PRIMARY KEY`, `agent_id TEXT`, `repo_path TEXT`, `branch TEXT`, `worktree_path TEXT`, `lifecycle TEXT`, `status TEXT`, `pid INTEGER`, `started_at INTEGER`, `last_activity_at INTEGER`, `closed_at INTEGER`, `exit_code INTEGER`, `log_path TEXT`, `error_message TEXT`, `agent_log_hint TEXT`, `artifact_dir TEXT`.
- Message: `id TEXT PRIMARY KEY`, `session_id TEXT`, `turn_id TEXT`, `role TEXT`, `content TEXT`, `created_at INTEGER`.

Notes:
- `lifecycle`: `oneshot` | `persistent`.
- `status` enums: `queued|starting|running|waiting_input|closing|closed|failed|canceled|timed_out`.
- Use INTEGER timestamps (ms since epoch) for simplicity.
- `turn_id` groups one user message with its assistant reply.

## Git Worktree Strategy
- Validate `repo_path` is a Git repo (check `.git` or `git rev-parse`).
- On Session create:
  - Worktree path: `<repo_path>/.awrapper-worktrees/<session_id>`
  - Command: `git -C <repo_path> worktree add -b aw/<session_id> <worktree_path> <branch>` (or reuse an existing branch; configurable)
  - Set Session cwd to the worktree.
- Do not auto‑clean worktrees on close (intentionally persist to allow returning to old Sessions). A later feature can add optional cleanup/suspend/resume.

## Process Execution Model

### Sessions (unified)
- Create Session:
  - `lifecycle = oneshot`: spawn process, optionally write `initial_message`, collect output until process exits, then mark `closed`.
  - `lifecycle = persistent`: spawn long‑lived process in worktree and keep it running for multiple turns.
- Turn handling (both lifecycles):
  - Enforce only one in‑flight turn via in‑memory mutex (per Session id).
  - Write user message to process stdin using the agent‑specific protocol (delimiter/JSON line/etc.).
  - Collect output until end‑of‑turn using one of:
    1) Known CLI turn delimiter/marker (preferred), or
    2) Quiet‑period flush (e.g., 500–800ms of no new bytes), or
    3) Prompt/prefix heuristic if available.
  - Persist one assistant Message for the turn with the captured text; update `last_activity_at`.
- Termination:
  - If the process exits, mark Session `closed`, set `exit_code`, and persist final logs.
  - `cancel`: send SIGTERM; escalate to SIGKILL after grace period.

### Agent Integration: codex
- Persistent sessions: prefer `codex proto` (stdin/stdout protocol) with `-C <worktree>` and minimal config overrides via `-c ...`. This enables clean multi‑turn programmatic control without a PTY.
- One‑shot sessions: prefer `codex exec --json` with `-C <worktree>` to emit JSONL events that the orchestrator ingests; capture last message and logs.
- Minimal flags to start: `-C/--cd`, `-m/--model` (optional), selective `-c` overrides; avoid approval/sandbox flags initially and inherit defaults.
- End‑of‑turn: with `exec --json`, read complete JSON stream until process exit. With `proto`, follow protocol messages and segment replies per turn; fall back to quiet‑period only if required.

## REST API (v0.1)

### Sessions (unified)
- POST `/sessions` — body: `{ agent_id: "codex", repo_path, branch?, lifecycle: "oneshot"|"persistent", params?, initial_message? }` → `{ id, worktree_path }`
- GET `/sessions` — list recent sessions with status
- GET `/sessions/:id` — detail: repo/branch/worktree, pid, status, lifecycle, last_activity_at, exit_code, agent_log_hint, transcript summary
- GET `/sessions/:id/log?tail=200` — last N lines (default 200); UI polls about every 250ms
- GET `/sessions/:id/artifacts` — list files under artifacts dir (if present)
- POST `/sessions/:id/cancel` — best effort terminate
- GET `/sessions/:id/messages?after=<message_id>` — messages after an id
- POST `/sessions/:id/messages` — `{ content }` → `{ message_id }` (queues one user turn)

## Minimal UI (Server‑Rendered + Fetch)
- Dashboard `/` — quick stats + link to Sessions
- Sessions List `/sessions` — table with status and lifecycle; “New Session” form (choose `oneshot` vs `persistent`)
- Session Detail `/sessions/:id` — transcript view, input box, indicator when a turn is in flight, log tail panel (poll every ~250ms), cancel button

## Logging & Redaction
- Wrapper logs: append stdout/stderr of the agent process to per‑Session `log_path`.
- Agent‑native logs (research): some agents (e.g., `codex`) write logs under their own dirs (e.g., `~/.codex`). We will:
  - Expose `agent_log_hint` in the Session detail (path/pattern).
  - (Optional) Phase 4 experiment: tail/ingest agent logs into the Session log with a source tag. Default off due to duplication and possible secret exposure.
- Basic redaction for obvious secrets (tokens/keys) before persisting to logs/transcripts.

## Configuration
- Defaults compiled in; optional `~/.awrapper/config.json` for overrides later.
- For v0.1, allow specifying paths and polling intervals via env vars if needed.

## Tech Stack (TypeScript throughout)
- Node.js 20+ with TypeScript
- HTTP: Fastify (or Express)
- DB: `better-sqlite3` (sync, simple)
- Process/PTY: `execa` + `node-pty` (PTY only if needed)
- Validation: `zod`
- Logging: `pino`
- IDs: `nanoid` or `uuid`
- Dev: `tsx`, ESLint, Prettier
 - Nice-to-haves: `fastify-type-provider-zod` (typed routes), `pino-pretty` (dev logs), `fs-extra` (fs ops), `pidtree` (kill process tree), `p-queue` (optional in-proc queue), `dotenv` (dev env), `ms` (durations)

## Implementation Plan

Phase 0 — Skeleton (0.5 day)
- Create project, init DB/dirs under `~/.awrapper` on boot
- Health route and minimal HTML layout

Phase 1 — Data & Registry (1 day)
- SQLite schema and simple migration on boot
- In‑code agents registry with `codex` (+ logging hints)
- Input validation utilities

Phase 2 — Sessions Core (2–3 days)
- Endpoints: create/list/detail/log tail/cancel/messages
- Worktree creation/validation; Session supervisor + process spawn
- Lifecycle handling: `oneshot` auto‑close vs `persistent` keepalive
- In‑flight turn lock; quiet‑period end‑of‑turn; transcript persistence
- Session UI: list + detail with polling

Phase 3 — Polish (0.5–1 day)
- Empty/error states; mobile CSS improvements
- Basic secret redaction; simple metrics (counts, durations)
- Expose `agent_log_hint` in UI; optional link

Phase 4 — Logging Research (0.5 day)
- Experiment with tailing/merging agent‑native logs (e.g., `~/.codex`)
- Decide default behavior (likely: disabled; link only)

Phase 5 — Packaging (0.5 day)
- `awrapper dev` and `awrapper start` commands
- README quickstart

## Acceptance Criteria
- Session created from UI returns id quickly; status/log tail visible; cancel works.
- `oneshot` lifecycle: process exits and session closes automatically with exit code; final logs preserved.
- `persistent` lifecycle: can send at least two user turns and receive assistant replies; single in‑flight turn enforced.
- DB persists across restarts; logs on disk; worktrees are not auto‑cleaned; UI usable on phone via LAN.
 - Omitting `lifecycle` defaults to `persistent`.

## Risks & Mitigations
- End‑of‑turn detection fragile → prefer CLI markers; add quiet‑period fallback with conservative thresholds.
- PTY quirks on macOS/Linux → avoid PTY unless required; if needed, scope to Sessions only.
- Agent‑native logging may duplicate content or include secrets → default to wrapper logs; link to agent logs; optional merge with redaction.
- Worktrees can accumulate → defer cleanup by design; add later maintenance tools (listing, manual pruning).
- File watching/heavy tools in worktree → v0.1 focuses on CLI interactions, not dev servers.

## Upgrade Path to PRD v1
- Isolation: replace local processes with rootless containers per Session.
- Networking: port publishing and discovery; optional reverse proxy for previews.
- Transport: WebSockets for faster updates; keep polling fallback.
- Security: single‑user token; later multi‑user Postgres + S3.
- UI: PWA polish; artifact viewers and richer previews.

## Open Questions
- Exact `codex` headless invocation and reliable EOT markers/protocol for turns.
- Do we want a "resume" concept to re‑attach to a previously persisted worktree with a fresh process, or is history via transcript sufficient in v0.1?
- What minimum set of agent params should be exposed in v0.1 (model, max tokens, system prompt)?
- Any other agent‑native log locations beyond `~/.codex` worth surfacing?
